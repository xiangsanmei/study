{
  "name": "chan",
  "version": "0.6.1",
  "description": "A go style channel implementation that works nicely with co",
  "main": "index.js",
  "scripts": {
    "test": "./node_modules/mocha/bin/mocha"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/brentburgoyne/chan"
  },
  "keywords": [
    "async",
    "go",
    "channel",
    "co",
    "generator"
  ],
  "author": {
    "name": "Brent Burgoyne"
  },
  "contributors": [
    {
      "name": "Brent Burgoyne"
    },
    {
      "name": "TJ Holowaychuk",
      "email": "tj@vision-media.ca"
    },
    {
      "name": "Eugene Ware",
      "email": "eugene@noblesamurai.com"
    }
  ],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/brentburgoyne/chan/issues"
  },
  "homepage": "https://github.com/brentburgoyne/chan",
  "devDependencies": {
    "co": "^3.0.6",
    "co-wait": "0.0.0",
    "expect.js": "^0.3.1",
    "mocha": "^1.20.1",
    "should": "^4.0.4",
    "sinon": "^1.10.3",
    "split": "^0.3.0",
    "superagent": "^0.18.0"
  },
  "readme": "# Chan\n\nA [golang](http://golang.org) like channel implementation for JavaScript that\nworks well with [co](https://github.com/visionmedia/co).\n\n[![Build Status](https://travis-ci.org/brentburgoyne/chan.png)](https://travis-ci.org/brentburgoyne/chan)\n[![Code Climate](https://codeclimate.com/github/brentburgoyne/chan.png)](https://codeclimate.com/github/brentburgoyne/chan)\n[![Dependency Status](https://gemnasium.com/brentburgoyne/chan.png)](https://gemnasium.com/brentburgoyne/chan)\n\n## Features\n\n- CSP Style channels in JavaScript\n- Buffered or Unbuffered channels\n- Channels can be closed\n- API designed to work well with generators and co\n- Can be used without generators\n- Channels can be selected similar to Go's select statement\n\n## Installation\n\n```bash\n$ npm install chan --save\n```\n\n## The Basics\n\nChan is inspired by golang's channels. It is implemented as a function that\nrepresents an asynchronous first in first out queue.\n\n```js\nvar makeChan = require('chan')\n// make a new unbuffered channel\nvar ch = makeChan()\ntypeof ch // -> 'function'\n```\n\n### Sending values to the channel\n\nValues are added to the\nchannel by calling the function with either `(value)` or `(error, value)`. The\nreturn value is a thunk (a function that take a node-style callback as its only\nargument). The callback given to the thunk is called once the value is added.\n\n```js\nch('foo')(function (err) {\n  if (err) {\n    // There was an error putting the value on the channel\n  } else {\n    // The value was successfully put on the channel\n  }\n})\n```\n\n### Receiving values from the channel\n\nValues are removed from the channel by calling it with a node-style callback as\nthis first argument. When a value is available on the channel the callback is\ncalled with the value or error. In this case the channel itself can also be a\nthunk.\n\n```js\nch(function (err, val) {\n  // called when there is a value or error on the channel\n})\n```\n\n### Generators\n\nBecause thunks are yield-able in a co generator, chan works very well when\ncombined with co. Using them together makes chan feel very similar to go\nchannels.\n\n```js\nvar co = require('co')\n\nco(function *() {\n  var val = yield ch\n})\n\nco(function *() {\n  yield ch('foo')\n})\n```\n\n## Buffer\n\nDocs coming soon...\n\n## Close\n\nDocs coming soon...\n\n## Select\n\nDocs coming soon...\n",
  "readmeFilename": "README.md",
  "_id": "chan@0.6.1",
  "_from": "chan@^0.6.1"
}
